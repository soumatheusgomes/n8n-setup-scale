#!/usr/bin/env bash
# n8n Workers-Only Deployment Script
#
# Deploys workers and runners on secondary servers connecting to main server.
#
# Usage:
#   ./deploy-workers-only.sh                        # Interactive
#   ./deploy-workers-only.sh <workers> [runners]    # Non-interactive
#
# Prerequisites:
#   - .env with Redis/PostgreSQL pointing to main server
#   - N8N_ENCRYPTION_KEY identical to main server
#   - N8N_RUNNERS_AUTH_TOKEN identical to main server

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$SCRIPT_DIR"

DEFAULT_WORKERS=4
DEFAULT_RUNNERS_PER_WORKER=1
WORKER_COMPOSE_FILE="docker-compose.worker.yml"

# Output helpers
print_info()    { echo ">> $1"; }
print_success() { echo "✅  $1"; }
print_error()   { echo "❌ ERROR: $1" >&2; }
print_warning() { echo "⚠️  WARNING: $1"; }

validate_number() {
  [[ "$1" =~ ^[0-9]+$ ]]
}

validate_env_vars() {
  local missing_vars=()
  local required_vars=(
    N8N_VERSION
    N8N_RUNNER_VERSION
    N8N_ENCRYPTION_KEY
    N8N_RUNNERS_AUTH_TOKEN
    QUEUE_BULL_REDIS_HOST
    REDIS_PASSWORD
    POSTGRES_HOST
    POSTGRES_PORT
    POSTGRES_DB
    POSTGRES_USER
    POSTGRES_PASSWORD
  )

  for var in "${required_vars[@]}"; do
    [[ -z "${!var:-}" ]] && missing_vars+=("$var")
  done

  if [[ ${#missing_vars[@]} -gt 0 ]]; then
    print_error "Missing required environment variables:"
    for var in "${missing_vars[@]}"; do
      echo "  - $var"
    done
    echo ""
    echo "Ensure .env contains all required variables matching main server."
    return 1
  fi
  return 0
}

prompt_workers() {
  local input
  read -rp "Number of workers? [Default: $DEFAULT_WORKERS]: " input
  echo "${input:-$DEFAULT_WORKERS}"
}

prompt_runners_per_worker() {
  local input
  read -rp "Runners per worker? [Default: $DEFAULT_RUNNERS_PER_WORKER]: " input
  echo "${input:-$DEFAULT_RUNNERS_PER_WORKER}"
}

generate_worker_compose() {
  print_info "Generating worker compose configuration..."

  cat > "$WORKER_COMPOSE_FILE" <<'EOF'
# n8n Workers-Only Compose (auto-generated by deploy-workers-only.sh)

services:
  n8n-worker:
    image: n8nio/n8n:${N8N_VERSION:-latest}
    command: worker
    restart: unless-stopped
    environment:
      NODE_ENV: production
      N8N_PROXY_HOPS: "1"
      N8N_RUNNERS_ENABLED: "true"
      N8N_RUNNERS_MODE: external
      N8N_RUNNERS_BROKER_LISTEN_ADDRESS: "0.0.0.0"
      N8N_RUNNERS_AUTH_TOKEN: ${N8N_RUNNERS_AUTH_TOKEN}
      N8N_NATIVE_PYTHON_RUNNER: "true"
      GENERIC_TIMEZONE: ${GENERIC_TIMEZONE:-UTC}
      EXECUTIONS_MODE: queue
      EXECUTIONS_DATA_SAVE_ON_ERROR: none
      EXECUTIONS_DATA_SAVE_ON_SUCCESS: none
      QUEUE_BULL_REDIS_HOST: ${QUEUE_BULL_REDIS_HOST}
      QUEUE_BULL_REDIS_PORT: ${QUEUE_BULL_REDIS_PORT:-6379}
      QUEUE_BULL_REDIS_PASSWORD: ${REDIS_PASSWORD}
      QUEUE_HEALTH_CHECK_ACTIVE: "true"
      DB_TYPE: postgresdb
      DB_POSTGRESDB_HOST: ${POSTGRES_HOST}
      DB_POSTGRESDB_PORT: ${POSTGRES_PORT:-5432}
      DB_POSTGRESDB_DATABASE: ${POSTGRES_DB}
      DB_POSTGRESDB_USER: ${POSTGRES_USER}
      DB_POSTGRESDB_PASSWORD: ${POSTGRES_PASSWORD}
      DB_POSTGRESDB_SSL_REJECT_UNAUTHORIZED: ${DB_POSTGRESDB_SSL_REJECT_UNAUTHORIZED:-false}
      N8N_ENCRYPTION_KEY: ${N8N_ENCRYPTION_KEY}
      N8N_ENFORCE_SETTINGS_FILE_PERMISSIONS: "true"
      OFFLOAD_MANUAL_EXECUTIONS_TO_WORKERS: "true"
    networks: [backend]

  n8n-worker-runners:
    image: n8nio/runners:${N8N_RUNNER_VERSION:-latest}
    restart: unless-stopped
    environment:
      N8N_RUNNERS_TASK_BROKER_URI: "http://n8n-worker:5679"
      N8N_RUNNERS_AUTH_TOKEN: ${N8N_RUNNERS_AUTH_TOKEN}
      N8N_RUNNERS_LAUNCHER_LOG_LEVEL: info
      N8N_RUNNERS_AUTO_SHUTDOWN_TIMEOUT: "15"
    depends_on: [n8n-worker]
    networks: [backend]

networks:
  backend:
    driver: bridge
EOF

  print_success "Generated: $WORKER_COMPOSE_FILE"
}

deploy_workers() {
  local workers="$1"
  local runners_scale="$2"

  print_info "Building worker images..."
  docker compose -f "$WORKER_COMPOSE_FILE" build

  print_info "Starting $workers worker(s) and $runners_scale runner(s)..."
  docker compose -f "$WORKER_COMPOSE_FILE" up -d \
    --scale n8n-worker="$workers" \
    --scale n8n-worker-runners="$runners_scale"

  print_info "Cleaning dangling images..."
  docker image prune -f
}

main() {
  if [[ ! -f .env ]]; then
    print_error ".env file not found!"
    echo "Create .env with required variables. See .env.example."
    exit 1
  fi

  set -a
  source .env
  set +a

  local workers="${1:-}"
  local runners_per_worker="${2:-}"

  # Get workers
  [[ -z "$workers" ]] && workers="$(prompt_workers)"
  if ! validate_number "$workers"; then
    print_warning "Invalid number. Using default: $DEFAULT_WORKERS"
    workers=$DEFAULT_WORKERS
  fi
  [[ "$workers" -lt 1 ]] && workers=1

  # Get runners per worker
  [[ -z "$runners_per_worker" ]] && runners_per_worker="$(prompt_runners_per_worker)"
  if ! validate_number "$runners_per_worker"; then
    print_warning "Invalid number. Using default: $DEFAULT_RUNNERS_PER_WORKER"
    runners_per_worker=$DEFAULT_RUNNERS_PER_WORKER
  fi
  [[ "$runners_per_worker" -lt 1 ]] && runners_per_worker=1

  local runners_scale=$((workers * runners_per_worker))

  print_info "Workers: $workers"
  print_info "Runners per worker: $runners_per_worker"
  print_info "Total runners: $runners_scale"

  if ! validate_env_vars; then
    exit 1
  fi

  generate_worker_compose
  deploy_workers "$workers" "$runners_scale"

  echo ""
  print_success "Workers deployed!"
  print_success "Workers: $workers | Runners: $runners_scale"
  echo ""
  echo "Monitor: docker compose -f $WORKER_COMPOSE_FILE logs -f"
}

main "$@"
